{"posts":[{"title":"图论","content":"强连通 tarjan算法 记录： bool in，记录是否在某个强连通分量中； low，这个点所能到达的最高点（dfs序） g，记录所在强连通分量的序号 dfn，dfs序 代码： vector&lt;int&gt; lines[10005]; struct Node { bool in; int g; int low; int dfn; }mp[10005]; int size[10005]; int g; int p; int ans; stack&lt;int&gt; st; void tarjan(int pos) { mp[pos].low = mp[pos].dfn = ++p; mp[pos].in = true; st.push(pos); F(i, 0, lines[pos].size() - 1) { if(!mp[lines[pos][i]].dfn) { tarjan(lines[pos][i]); mp[pos].low = min(mp[pos].low, mp[lines[pos][i]].low); } else if(mp[lines[pos][i]].in) { mp[pos].low = min(mp[pos].low, mp[lines[pos][i]].dfn); } } if(mp[pos].low == mp[pos].dfn) { mp[pos].g = ++g; mp[pos].in = false; int id = 10000000; do { id = st.top(); mp[id].g = g; size[g]++; mp[id].in = false; st.pop(); } while (id != pos); } } 解释：假如连接的下个点没有dfn（没走过），正常走，此点的low取两者的最小值；假如连接的下个点走过，更新low就可以了；假如一个点的low等于它本身，说明它就是这个强连通分量的最高点，此时栈中所有比pos后入栈的点都在pos所在的强连通分量中。 缩点 边所连接的两点不在同一强连通分量的边全部连向top，在同一强连通分量的边删除，点的权值全部加给top top指强连通分量中dfs序最小的点 割点 当此点为根节点时，假如子树数量大于1，那么此点必为割点 虽然是张无向图，但是我们是dfs遍历，因此我们每次回到根节点都相当于遍历完一颗子树，关于这颗子树上有没有环我们不关心 对于非根节点，我们只需判断它的所有子节点中有无点的low（可回溯到的最高点）是否大于等于当前点，如果是，那么说明删去当前点的话这个子节点就无法与此节点上方的节点联通，因此此点为割点 最短路 dijkstra算法，需要用优先队列，可以处理单源最短路径，但不可以有权值为负数的边 核心代码： point tmp; p[s] = 0; tmp.id = s; tmp.d = 0; m.push(tmp); while(!m.empty()) { int ps = m.top().id; int dis = m.top().d; m.pop(); if(trig[ps]) continue; trig[ps] = true; for(int i = 0; i &lt; z[ps].size(); i++) { int ad = dis + z[ps][i].d; if(ad &lt; p[z[ps][i].t] &amp;&amp; !trig[z[ps][i].t]) { p[z[ps][i].t] = ad; point tmp; tmp.id = z[ps][i].t; tmp.d = ad; m.push(tmp); } } } 生成树 kruscal算法：将边按权值从小到大排列；遍历每条边，假如这条边连接的两个点不连通（用并查集维护），那么就连上这条边，ans+=权值，一直操作到边数等于点数-1（树的边数） #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int n, m; long ans; int p; vector&lt;int&gt; b[5005]; struct line { int x, y, len; }lines[200005]; int f[200005]; bool cmp(line x, line y) { return x.len &lt; y.len; } int find(int x) { if(x != f[x]) { f[x] = find(f[x]); return f[x]; } else return x; } int main() { cin &gt;&gt; n &gt;&gt; m; p = 0; for(int i = 1; i &lt;= m; i++) { int t, m, p; cin &gt;&gt; t &gt;&gt; m &gt;&gt; p; lines[i].x = min(t, m); lines[i].y = max(t, m); lines[i].len = p; } for(int i = 1; i &lt;= n; i++) { f[i] = i; } sort(lines + 1, lines + 1 + m, cmp); for(int i = 1; i &lt;= m; i++) { if(p == n - 1) break; int x = lines[i].x, y = lines[i].y; y = find(y); x = find(x); if(f[x] != f[y]) { p++; f[y] = x; find(y); ans += lines[i].len; } } if(p != n - 1) cout &lt;&lt; &quot;orz&quot;; else cout &lt;&lt; ans; return 0; } ","link":"https://L1nkzz.github.io/post/tu-lun/"},{"title":"bugs","content":"重点 freopen！ long long! 用快读的话，不要忘记把快读的返回值改成longlong， 里面的整数n也要改成longlong， printf(&quot;%lld&quot;) int main()! 因为忘记开ll直接ctrl+F把全部int替换成ll cin,cout不能和printf,scanf,快读等混用 别忘加头文件！ if里是用==不是= 迟诚行为 线段树 习惯：add(int pos, int l, int r, int nl, int nr, int k) find(int pos, int l, int r, int nl, int nr) pos指线段树中当前下标，l、r为所要求的l、r，nl、nr为nowl,nowr，即为现在所在的区间端点 数组开四倍大小 add、find中mid = nl + nr &gt;&gt; 1; 向下遍历时：if(l &lt;= mid) 和 if(r &gt; mid) 一定要记住在函数中间写down，结尾写up！ down里num[pos &lt;&lt; 1] + ltag[pos] * (mid - l + 1)！千万不能直接写size = r - l + 1 &gt;&gt; 1; 主函数调用函数的参数一定要一一对应，不能够上面void doit(int size, int pos)下面调用时doit(pos, size) 不要图方便把mid等变量改成全局变量 maketree()、add()等等没有返回值的函数，l==r或者nl &gt;= l &amp;&amp; nr &lt;= r等函数结束时，不要忘记return来避免继续递归 树链剖分 dfs1，处理f，depth，bson(biggest_son)，size 如何判断连的边不是父节点？lines[pos][i] != list[pos].f dfs2，处理dfs序，将点的权值按照dfs序传入数组，方便建立线段树；处理重链的顶点 dfs序一定要bson优先，这样能保证一条重链上的dfs序号连续 莫队算法 离线！ 询问排序：优先按左端点的块的编号排序，其次按右端点排序 核心 指针st， ed，对于排序后的每个询问进行指针的左右移动，同时对ans进行修改 矩阵相乘 矩阵a(n, m), b(m, k)，相乘得到c(m, m); c(x, y)为a第x行每个值与b第y行每个值的乘积之和 强连通 while从栈中取数时，判断条件为while (id != pos)，不能写list[st.top()].dfn != xxxxxxx.low，因为同一强连通分量里可能会有不止一个点满足这一条件 最短路 优！先！队！列！的！比！较！函！数！是！反！过！来！的！写！大！于！号！就！成！了！小！根！堆！ 记得开visit数组记录此节点走没走过，否则时间会爆炸的 要把mindis数组初始化为INT_MAX 优先队列取完队首要立刻出栈！！！ 在加入优先队列时，一定要优先更新mindis数组，否则q.top()可能会改变，也不要一定以为新加入的点一定是最小值； 错误如下：points tmp; tmp.pos = id; tmp.d = dis; q.push(tmp); d[id] = q.top().d; 生成树 保证每条边的x、y有序，x小于y，这样方便维护并查集 ","link":"https://L1nkzz.github.io/post/bugs/"},{"title":"数 学","content":"正在被数学血虐。。。等抽空把相关内容更上来吧 数学一本通，折磨滴神 指中考后 ","link":"https://L1nkzz.github.io/post/shu-xue/"},{"title":"学习清单","content":" 三分 模拟退火 数论 线段树 树链剖分 网络流 CDQ分治 ","link":"https://L1nkzz.github.io/post/xue-xi-qing-dan/"},{"title":"清 北 学 堂 国 庆 七 日 游","content":"ytez除了我都强的离谱 我不是ytez的啊，那没事了 不管题了，直接讲课件 搜 索 与 枚 举 课件中枚举里最难的就是水仙花数所以略过 搜索 广度优先搜索（BFS被反杀） 深度优先搜索（DFS大法师） 记忆化搜索 迭代加深搜索（IDFS爱大法师） A* IDA* meet in the middle 爬山算法 模拟退火 深度优先搜索 例：想象你面前有一棵树 你现在在一号点，你想找到树中与一号点连通的每一个点 那么我们考虑按照深度优先的顺序去遍历这棵树，即，假设你当前在点x，如果和x连边的点中有一个点y，满足y比x深，即y是x的儿子，并且y还没有被访问过，那么我们就走到y，如果有多个y满足条件，我们走到其中任意一个 如果没有y满足条件，我们返回x的父亲 按照这个顺序，我们就可以访问到每个节点，并且每条边会恰好被走两次（从父亲到儿子一次，从儿子到父亲一次） 小 试 牛 刀 遍历一张图 void dfs(int x){ int i; vis[x]=1; for(i=1;i&lt;=n;i++){ if(mp[x][i]&amp;&amp;!vis[i]){ dfs(i); } } } 枚举一个集合中的所有子集 void dfs(int x){ if(x&gt;n){ //得到了一个子集 return ; } s[++tot]=a[x]; dfs(x+1);//选第x位 tot--; dfs(x+1);//不选 } 如何用dfs判断一个图里有没有环？ void dfs(int pos) { vis[i] = true; for(int i = 1; i &lt;= c[pos]; i++) { if(vis[next[pos][i]]) { cout &lt;&lt; -1; return; } dfs(next[pos][i]); } } 八皇后问题 在一个n*n的棋盘上摆n个皇后，使他们两两不能互相攻击到，求方案数 N&lt;=10 void dfs(int step) { for(int i = 1; i &lt;= n; i++) { if(!trigs[i]) { bool trig = true; for(int j = 1; j &lt; step; j++) { { if(hangs[j] + step - j == i || hangs[j] - step + j == i) { trig = false; break; } } } if(trig) { hangs[step] = i; if(step == n) { times++; break; } else { trigs[i] = 1; dfs(step + 1); trigs[i] = 0; } } } } } NOI1999 生日蛋糕 dfs需要传哪些状态？ 第i层 高度 半径 表面积 体积 剪枝时间~ 可行性剪枝：剩余的材料太少或太多，不足以构造剩余层数的蛋糕，剪枝； 最优化剪枝：如果当前已用表面积加上余下最小的侧面积大于已知最优解，剪枝； 广度优先搜索 例：还是想像一棵树 你现在还是在一号点，你还是想找到树中与一号点连通的每一个点 我们初始的时候把一号点推入队取出队尾，然后只要当前队列非空，我们就取出队头元素x，并将队头弹出 然后我们将x的所有儿子推入队列 对于图上的情况，我们将所有与x相连，并且还没入过队的点推入队列 这样我们就能够访问所有点 void bfs(){ q[tl++]=s; while(hd!=tl){ x=q[hd++]; for(i=1;i&lt;=n;i++){ if(mp[x][i]&amp;&amp;!vis[i]){ q[tl++]=i; vis[i]=1; } } } } [HAOI2008]移动玩具 将4*4的矩阵看做一排，变成长度为16的二进制数，dfs即可 记忆化搜索 假设你现在有一个有向无环图 你要求从1号节点出发的最长的路径 我们可以令f[i]表示从i出发的最长的路径 那么f[x]=max(f[y]+len)，len为x到y的边的长度 f[1]即为答案 我们可以通过dfs来求f值，而这样的话复杂度是指数级的 我们发现在搜索过程中，我们会搜索重复的状态，即，不论你从x开始搜索几次，你得到的答案都是一样的 那么我们不妨记录一下每个点是否被搜索过，以及搜索的结果是什么 如果当前要搜的点已经被搜索过了，我们就直接返回结果 这就叫做记忆化搜索 实质为动态规划 所有的动态规划都能用记忆化搜索实现，但常数会很大 记忆化搜索不需要按照拓扑序，因为搜索的过程本身就遵循拓扑序 计数 一副不含王的扑克牌由52张牌组成，由红桃、黑桃、梅花、方块4组牌组成，每组13张不同的面值。现在给定52张牌中的若干张，请计算将它们排成一列，相邻的牌面值不同的方案数。 记录13种面值的出现次数，进行记忆化搜索 IDFS 有些情况下，我们无法直接进行dfs或bfs，因为你要搜索的图可能是无限大的，每个点所连的边也可能有无限多条，此时dfs和bfs同时失效。 IDFS：在进行dfs时对搜索深度进行限制，这样就将无限大小的图缩为有限大小的图，可以进行搜索（结合bfs和dfs） 小 试 牛 刀 埃及分数IG粉丝 枚举相加分数的个数，则第一个枚举到的状态为最佳状态。 这样就成功的将无限的深度转变为有限的深度。 A* A*，常见于游戏中的自动寻路。 设已经消耗的代价为f(x)f(x)f(x)，估算从x到终点的代价为h(x)h(x)h(x)，设g(x)=f(x)+h(x)g(x)=f(x)+h(x)g(x)=f(x)+h(x)那么用优先队列来维护g(x)g(x)g(x)最小的点，进行搜索 h(x)h(x)h(x)是A*的精髓，h(x)h(x)h(x)越接近于实际代价，A*效率越高。但是h(x)h(x)h(x)不能够大于实际代价，就会导致答案错误。 小 试 牛 刀 八数码问题 两种可行的h函数 1.不应该在这个位置的数字数 2.所用数字距离应在位置的曼哈顿距离 K短路问题(紫题，不会被卡) 黑题，会被卡掉一个点 用A*，遍历到终点的第K次就是K短路问题 h(x)h(x)h(x)为x到终点的最短路 IDA* 在进行IDFS的时候，我们也可以用A*进行搜索 如果在当前深度限制下搜到了结束状态，我们就可以直接输出答案 如果没有搜到答案，我们可以把深度限制更新为最小的f(x) 解析：当f(x)f(x)f(x)超过要求深度时，剪枝。 小 试 牛 刀 [poj2286]The Rotation Game IDA*，思路同埃及分数，枚举移动步数，设h(x)h(x)h(x)为8-中间8个数中出现次数最多的那个数（最少移动次数） [SCOI2005]骑士精神 ","link":"https://L1nkzz.github.io/post/qing-bei-xue-tang-guo-qing-qi-ri-you/"}]}