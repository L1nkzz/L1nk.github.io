{"posts":[{"title":"清 北 学 堂 国 庆 七 日 游","content":"ytez除了我都强的离谱 我不是ytez的啊，那没事了 不管题了，直接讲课件 搜 索 与 枚 举 课件中枚举里最难的就是水仙花数所以略过 搜索 广度优先搜索（BFS被反杀） 深度优先搜索（DFS大法师） 记忆化搜索 迭代加深搜索（IDFS爱大法师） A* IDA* meet in the middle 爬山算法 模拟退火 深度优先搜索 例：想象你面前有一棵树 你现在在一号点，你想找到树中与一号点连通的每一个点 那么我们考虑按照深度优先的顺序去遍历这棵树，即，假设你当前在点x，如果和x连边的点中有一个点y，满足y比x深，即y是x的儿子，并且y还没有被访问过，那么我们就走到y，如果有多个y满足条件，我们走到其中任意一个 如果没有y满足条件，我们返回x的父亲 按照这个顺序，我们就可以访问到每个节点，并且每条边会恰好被走两次（从父亲到儿子一次，从儿子到父亲一次） 小 试 牛 刀 遍历一张图 void dfs(int x){ int i; vis[x]=1; for(i=1;i&lt;=n;i++){ if(mp[x][i]&amp;&amp;!vis[i]){ dfs(i); } } } 枚举一个集合中的所有子集 void dfs(int x){ if(x&gt;n){ //得到了一个子集 return ; } s[++tot]=a[x]; dfs(x+1);//选第x位 tot--; dfs(x+1);//不选 } 如何用dfs判断一个图里有没有环？ void dfs(int pos) { vis[i] = true; for(int i = 1; i &lt;= c[pos]; i++) { if(vis[next[pos][i]]) { cout &lt;&lt; -1; return; } dfs(next[pos][i]); } } 八皇后问题 在一个n*n的棋盘上摆n个皇后，使他们两两不能互相攻击到，求方案数 N&lt;=10 void dfs(int step) { for(int i = 1; i &lt;= n; i++) { if(!trigs[i]) { bool trig = true; for(int j = 1; j &lt; step; j++) { { if(hangs[j] + step - j == i || hangs[j] - step + j == i) { trig = false; break; } } } if(trig) { hangs[step] = i; if(step == n) { times++; break; } else { trigs[i] = 1; dfs(step + 1); trigs[i] = 0; } } } } } NOI1999 生日蛋糕 dfs需要传哪些状态？ 第i层 高度 半径 表面积 体积 剪枝时间~ 可行性剪枝：剩余的材料太少或太多，不足以构造剩余层数的蛋糕，剪枝； 最优化剪枝：如果当前已用表面积加上余下最小的侧面积大于已知最优解，剪枝； 广度优先搜索 例：还是想像一棵树 你现在还是在一号点，你还是想找到树中与一号点连通的每一个点 我们初始的时候把一号点推入队取出队尾，然后只要当前队列非空，我们就取出队头元素x，并将队头弹出 然后我们将x的所有儿子推入队列 对于图上的情况，我们将所有与x相连，并且还没入过队的点推入队列 这样我们就能够访问所有点 void bfs(){ q[tl++]=s; while(hd!=tl){ x=q[hd++]; for(i=1;i&lt;=n;i++){ if(mp[x][i]&amp;&amp;!vis[i]){ q[tl++]=i; vis[i]=1; } } } } [HAOI2008]移动玩具 将4*4的矩阵看做一排，变成长度为16的二进制数，dfs即可 记忆化搜索 假设你现在有一个有向无环图 你要求从1号节点出发的最长的路径 我们可以令f[i]表示从i出发的最长的路径 那么f[x]=max(f[y]+len)，len为x到y的边的长度 f[1]即为答案 我们可以通过dfs来求f值，而这样的话复杂度是指数级的 我们发现在搜索过程中，我们会搜索重复的状态，即，不论你从x开始搜索几次，你得到的答案都是一样的 那么我们不妨记录一下每个点是否被搜索过，以及搜索的结果是什么 如果当前要搜的点已经被搜索过了，我们就直接返回结果 这就叫做记忆化搜索 实质为动态规划 所有的动态规划都能用记忆化搜索实现，但常数会很大 记忆化搜索不需要按照拓扑序，因为搜索的过程本身就遵循拓扑序 计数 一副不含王的扑克牌由52张牌组成，由红桃、黑桃、梅花、方块4组牌组成，每组13张不同的面值。现在给定52张牌中的若干张，请计算将它们排成一列，相邻的牌面值不同的方案数。 记录13种面值的出现次数，进行记忆化搜索 IDFS 有些情况下，我们无法直接进行dfs或bfs，因为你要搜索的图可能是无限大的，每个点所连的边也可能有无限多条，此时dfs和bfs同时失效。 IDFS：在进行dfs时对搜索深度进行限制，这样就将无限大小的图缩为有限大小的图，可以进行搜索（结合bfs和dfs） 小 试 牛 刀 埃及分数IG粉丝 枚举相加分数的个数，则第一个枚举到的状态为最佳状态。 这样就成功的将无限的深度转变为有限的深度。 A* A*，常见于游戏中的自动寻路。 设已经消耗的代价为f(x)f(x)f(x)，估算从x到终点的代价为h(x)h(x)h(x)，设g(x)=f(x)+h(x)g(x)=f(x)+h(x)g(x)=f(x)+h(x)那么用优先队列来维护g(x)g(x)g(x)最小的点，进行搜索 h(x)h(x)h(x)是A*的精髓，h(x)h(x)h(x)越接近于实际代价，A*效率越高。但是h(x)h(x)h(x)不能够大于实际代价，就会导致答案错误。 小 试 牛 刀 八数码问题 两种可行的h函数 1.不应该在这个位置的数字数 2.所用数字距离应在位置的曼哈顿距离 K短路问题(紫题，不会被卡) 黑题，会被卡掉一个点 用A*，遍历到终点的第K次就是K短路问题 h(x)h(x)h(x)为x到终点的最短路 IDA* 在进行IDFS的时候，我们也可以用A*进行搜索 如果在当前深度限制下搜到了结束状态，我们就可以直接输出答案 如果没有搜到答案，我们可以把深度限制更新为最小的f(x) 解析：当f(x)f(x)f(x)超过要求深度时，剪枝。 小 试 牛 刀 [poj2286]The Rotation Game IDA*，思路同埃及分数，枚举移动步数，设h(x)h(x)h(x)为8-中间8个数中出现次数最多的那个数（最少移动次数） [SCOI2005]骑士精神 ","link":"https://L1nkzz.github.io/post/qing-bei-xue-tang-guo-qing-qi-ri-you/"}]}