{"posts":[{"title":"题解 P4981父子 (Carley定理)","content":"原题链接 题意 构造一棵含n个带序号的点的有根树，求方案数 Carley定理~ Carley定理：n个带序号的节点共能构成nn−2n^{n-2}nn−2个形态不同的无根树 套！ Carley定理处理的是无根树，而这题是有根树；树的每种形态都有n个点可做根，所以总方案数为nn−1n^{n-1}nn−1 核心代码 int main() { int t; read(t); F(i, 1, t) { ll n; read(n); write(qpow(n, n-1), '\\n'); } return 0; } 全代码 // Problem: P4981 父子 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P4981 // Memory Limit: 128 MB // Time Limit: 1000 ms // Powered by CP Editor (https://github.com/cpeditor/cpeditor) //#include &lt;bits/stdc++.h&gt; #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;math.h&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;climits&gt; #include &lt;functional&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;deque&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;bitset&gt; #include &lt;complex&gt; //#include &lt;ext/pb_ds/assoc_container.hpp&gt; //#include &lt;ext/pb_ds/tree_policy.hpp&gt; #define itn int #define nit int #define ll long long #define ms multiset #define F(i, a, b) for(register int i = a, i##end = b; i &lt;= i##end; ++i) #define UF(i, a, b) for(register int i = a, i##end = b; i &gt;= i##end; --i) #define re register #define ri re int #define il inline #define pii pair&lt;int, int&gt; #define cp complex&lt;double&gt; //#pra gma G CC opti mize(3) using namespace std; using std::bitset; //using namespace __gnu_pbds; const double Pi = acos(-1); namespace fastIO { template&lt;class T&gt; inline void read(T &amp;x) { x = 0; bool fu = 0; char ch = 0; while(ch &gt; '9' || ch &lt; '0') { ch = getchar(); if(ch == '-') fu = 1; } while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x * 10 - 48 + ch), ch = getchar(); if(fu) x = -x; } inline int read() { int x = 0; bool fu = 0; char ch = 0; while(ch &gt; '9' || ch &lt; '0') { ch = getchar(); if(ch == '-') fu = 1; } while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x * 10 - 48 + ch), ch = getchar(); return fu ? -x : x; } char _n_u_m_[40]; template&lt;class T&gt; inline void write(T x ) { if(x == 0) { putchar('0'); return; } T tmp = x &gt; 0 ? x : -x; if(x &lt; 0) putchar('-'); register int cnt = 0; while(tmp &gt; 0) { _n_u_m_[cnt++] = tmp % 10 + '0'; tmp /= 10; } while(cnt &gt; 0) putchar(_n_u_m_[--cnt]); } template&lt;class T&gt; inline void write(T x ,char ch) { write(x); putchar(ch); } } using namespace fastIO; ll mod = 1e9 + 9; ll qpow(ll n, ll k) { ll tmp = 1; while(k) { if(k &amp; 1) { tmp *= n; tmp %= mod; } k &gt;&gt;= 1; n *= n; n %= mod; } return tmp; } int main() { int t; read(t); F(i, 1, t) { ll n; read(n); write(qpow(n, n-1), '\\n'); } return 0; } ","link":"https://L1nkzz.github.io/post/ti-jie-p4981-fu-zi-carley-ding-li/"},{"title":"bugs","content":"不开unsigned long long见祖宗！！！！！ 重点 freopen！ long long! 用快读的话，不要忘记把快读的返回值改成longlong， 里面的整数n也要改成longlong， printf(&quot;%lld&quot;) int main()! 因为忘记开ll直接ctrl+F把全部int替换成ll cin,cout不能和printf,scanf,快读等混用 别忘加头文件！ if里是用==不是= 迟诚行为 线段树 习惯：add(int pos, int l, int r, int nl, int nr, int k) find(int pos, int l, int r, int nl, int nr) pos指线段树中当前下标，l、r为所要求的l、r，nl、nr为nowl,nowr，即为现在所在的区间端点 数组开四倍大小 add、find中mid = nl + nr &gt;&gt; 1; 向下遍历时：if(l &lt;= mid) 和 if(r &gt; mid) 一定要记住在函数中间写down，结尾写up！ down里num[pos &lt;&lt; 1] + ltag[pos] * (mid - l + 1)！千万不能直接写size = r - l + 1 &gt;&gt; 1; 主函数调用函数的参数一定要一一对应，不能够上面void doit(int size, int pos)下面调用时doit(pos, size) 不要图方便把mid等变量改成全局变量 maketree()、add()等等没有返回值的函数，l==r或者nl &gt;= l &amp;&amp; nr &lt;= r等函数结束时，不要忘记return来避免继续递归 树链剖分 dfs1，处理f，depth，bson(biggest_son)，size 如何判断连的边不是父节点？lines[pos][i] != list[pos].f dfs2，处理dfs序，将点的权值按照dfs序传入数组，方便建立线段树；处理重链的顶点 dfs序一定要bson优先，这样能保证一条重链上的dfs序号连续 莫队算法 离线！ 询问排序：优先按左端点的块的编号排序，其次按右端点排序 核心 指针st， ed，对于排序后的每个询问进行指针的左右移动，同时对ans进行修改 矩阵相乘 矩阵a(n, m), b(m, k)，相乘得到c(n, k); c(x, y)为a第x行每个值与b第y行每个值的乘积之和 强连通 while从栈中取数时，判断条件为while (id != pos)，不能写list[st.top()].dfn != xxxxxxx.low，因为同一强连通分量里可能会有不止一个点满足这一条件 最短路 优！先！队！列！的！比！较！函！数！是！反！过！来！的！写！大！于！号！就！成！了！小！根！堆！ 记得开visit数组记录此节点走没走过，否则时间会爆炸的 要把mindis数组初始化为INT_MAX 优先队列取完队首要立刻出栈！！！ 在加入优先队列时，一定要优先更新mindis数组，否则q.top()可能会改变，也不要一定以为新加入的点一定是最小值； 错误如下：points tmp; tmp.pos = id; tmp.d = dis; q.push(tmp); d[id] = q.top().d; 生成树 保证每条边的x、y有序，x小于y，这样方便维护并查集 网络流 权值在边上不在点上不要犯搞混点编号和边编号的nt错误。。。。 dfs里要注意num &lt;= 0 的时候就要退出循环，没有贡献了 pos初始必须是奇数，即保证一对正反边奇数序号较大偶数序号较小这样可以直接异或计算 ","link":"https://L1nkzz.github.io/post/bugs/"}]}