{"posts":[{"title":"清 北 学 堂 国 庆 七 日 游","content":"ytez除了我都强的离谱 我不是ytez的啊，那没事了 不管题了，直接讲课件 搜 索 与 枚 举 课件中枚举里最难的就是水仙花数所以略过 搜索 广度优先搜索（BFS被反杀） 深度优先搜索（DFS大法师） 记忆化搜索 迭代加深搜索（IDFS爱大法师） A* IDA* meet in the middle 爬山算法 模拟退火 深度优先搜索 例：想象你面前有一棵树 你现在在一号点，你想找到树中与一号点连通的每一个点 那么我们考虑按照深度优先的顺序去遍历这棵树，即，假设你当前在点x，如果和x连边的点中有一个点y，满足y比x深，即y是x的儿子，并且y还没有被访问过，那么我们就走到y，如果有多个y满足条件，我们走到其中任意一个 如果没有y满足条件，我们返回x的父亲 按照这个顺序，我们就可以访问到每个节点，并且每条边会恰好被走两次（从父亲到儿子一次，从儿子到父亲一次） 小 试 牛 刀 遍历一张图 void dfs(int x){ int i; vis[x]=1; for(i=1;i&lt;=n;i++){ if(mp[x][i]&amp;&amp;!vis[i]){ dfs(i); } } } 枚举一个集合中的所有子集 void dfs(int x){ if(x&gt;n){ //得到了一个子集 return ; } s[++tot]=a[x]; dfs(x+1);//选第x位 tot--; dfs(x+1);//不选 } 如何用dfs判断一个图里有没有环？ void dfs(int pos) { vis[i] = true; for(int i = 1; i &lt;= c[pos]; i++) { if(vis[next[pos][i]]) { cout &lt;&lt; -1; return; } dfs(next[pos][i]); } } 八皇后问题 在一个n*n的棋盘上摆n个皇后，使他们两两不能互相攻击到，求方案数 N&lt;=10 void dfs(int step) { for(int i = 1; i &lt;= n; i++) { if(!trigs[i]) { bool trig = true; for(int j = 1; j &lt; step; j++) { { if(hangs[j] + step - j == i || hangs[j] - step + j == i) { trig = false; break; } } } if(trig) { hangs[step] = i; if(step == n) { times++; break; } else { trigs[i] = 1; dfs(step + 1); trigs[i] = 0; } } } } } NOI1999 生日蛋糕 dfs需要传哪些状态？ 第i层 高度 半径 表面积 体积 剪枝时间~ 可行性剪枝：剩余的材料太少或太多，不足以构造剩余层数的蛋糕，剪枝； 最优化剪枝：如果当前已用表面积加上余下最小的侧面积大于已知最优解，剪枝； 写暴力即可 ","link":"https://L1nkzz.github.io/post/qing-bei-xue-tang-guo-qing-qi-ri-you/"}]}